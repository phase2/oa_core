<?php
/**
 * @file
 * Code for the Open Atrium Archive feature.
 */

include_once 'oa_archive.features.inc';

/**
 * Implements hook_node_access().
 *
 * Deny delete access when trash flag is in use.
 */
function oa_archive_node_access($node, $op, $account) {
  if (($op == 'delete') && variable_get('oa_archive_disable_delete', FALSE) &&  module_exists('trash_flag')) {
    return NODE_ACCESS_DENY;
  }
}

/**
 * Implements hook_flag().
 *
 * We need to archive/unarchive child content when archiving a Space or
 * Section. We handle unarchiving parents who had child content that was
 * already archived by storing a list of those nodes in a variable.
 */
function oa_archive_flag($action, $flag, $content_id, $account) {
  if ($flag->name == 'trash') {
    $node = node_load($content_id);

    // We only deal with Spaces or Sections.
    if (empty($node) || !in_array($node->type, array(OA_SPACE_TYPE, OA_SECTION_TYPE))) {
      return;
    }

    // Get all the child NIDs.
    if ($node->type == OA_SPACE_TYPE) {
      $child_nids = array_merge(
        _oa_archive_get_subspaces($node->nid),
        _oa_archive_get_sections($node->nid));
    }
    elseif ($node->type == OA_SECTION_TYPE) {
      $child_nids = _oa_archive_get_section_content($node->nid);
    }

    $already_archived_variable = 'oa_archive_node_' . $node->nid . '_already_archived';

    // Since we are recursively flagging child content, we need to record which
    // child nodes were already archived, so that we can leave them in that
    // state when unarchiving the parent.
    if ($action == 'flag') {
      $already_archived = _oa_archive_find_archived_nodes($child_nids);
      variable_set($already_archived_variable, $already_archived);
    }
    else {
      // If we're unflagging, so we need to pull this list from storage.
      $already_archived = variable_get($already_archived_variable, array());
      variable_delete($already_archived_variable);
    }

    // We don't need to bother archiving content that's already archived, or
    // unarchiving content that should remain that way.
    $child_nids = array_diff($child_nids, $already_archived);

    // Fire off a batch operation to do the flagging/unflagging.
    $batch = array(
      'title' => $action == 'flag' ? t('Archiving content') : t('Unarchiving content'),
      'operations' => array(),
    );
    foreach ($child_nids as $nid) {
      $batch['operations'][] = array('_oa_archive_batch_operation', array($action, $nid));
    }
    batch_set($batch);
  }
}

/**
 * Gets all the content within a particular Section.
 *
 * @param int $nid
 *   The node ID of the Section.
 *
 * @return array
 *   An array of node IDs.
 */
function _oa_archive_get_section_content($nid) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('status', 1)
    ->fieldCondition('oa_section_ref', 'target_id', $nid);
  $result = $query->execute();
  if (isset($result['node'])) {
    return array_keys($result['node']);
  }
  return array();
}

/**
 * Gets all the sub-Spaces within a particular Space..
 *
 * @param int $nid
 *   The node ID of the Space.
 *
 * @return array
 *   An array of node IDs.
 */
function _oa_archive_get_subspaces($nid) {
  $associated_entities = og_subgroups_get_associated_entities('node', $nid);
  if (!empty($associated_entities['node'])) {
    return array_values($associated_entities['node']);
  }
  return array();
}

/**
 * Gets all the Sections within a particular Space..
 *
 * @param int $nid
 *   The node ID of the Space.
 *
 * @return array
 *   An array of node IDs.
 */
function _oa_archive_get_sections($nid) {
  return array_keys(oa_core_space_sections($nid, NODE_PUBLISHED));
}

/**
 * Get the archived nodes from a list.
 *
 * @param array $nids
 *   Array of NIDs to check.
 *
 * @return array
 *   Array of all the archived NIDs.
 */
function _oa_archive_find_archived_nodes($nids) {
  $result = array();
  if ($flag = flag_get_flag('trash')) {
    foreach ($nids as $nid) {
      if ($flag->is_flagged($nid)) {
        $result[] = $nid;
      }
    }
  }
  return $result;
}

/**
 * Batch operation that flags or unflags a child node.
 *
 * @param string $action
 *   Either "flag" or "unflag".
 * @param int $nid
 *   The NID to flag or unflag.
 */
function _oa_archive_batch_operation($action, $nid, &$context) {
  if ($flag = flag_get_flag('trash')) {
    $flag->flag($action, $nid);
  }
}
